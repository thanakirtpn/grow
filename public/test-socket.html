<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Socket.IO Audio/Video Call Test</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      background: #f8f8f8;
    }

    #log {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid #ccc;
      height: 300px;
      overflow-y: scroll;
      margin-top: 1rem;
      font-family: monospace;
      white-space: pre-wrap;
    }

    input, button {
      margin: 0.25rem;
      padding: 0.5rem;
    }

    #videoContainer {
      display: flex;
      gap: 1.5rem;
      margin-top: 1.5rem;
      justify-content: center;
    }

    .video-box {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .video-label {
      font-weight: bold;
      margin-bottom: 0.25rem;
      font-size: 1rem;
      color: #444;
    }

    video {
      width: 300px;
      height: 225px;
      background: #000;
      border-radius: 10px;
      border: 2px solid #ccc;
    }
  </style>
</head>
<body>
  <h1>üì° Socket.IO Audio/Video Call Test</h1>

  <div>
    <label><b>Your User ID:</b></label>
    <input type="number" id="userId" value="1" />
    <button onclick="connectSocket()">Connect</button>
  </div>

  <div>
    <label><b>Receiver ID:</b></label>
    <input type="number" id="receiverId" value="2" />
    <input type="text" id="message" placeholder="Type message..." />
    <button onclick="sendMessage()">Send Message</button>
  </div>

  <div>
    <button onclick="startCall('VOICE')">üìû Start Audio Call</button>
    <button onclick="startCall('VIDEO')">üìπ Start Video Call</button>
    <button onclick="acceptCall()">‚úÖ Accept</button>
    <button onclick="declineCall()">‚ùå Decline</button>
    <button onclick="endCall()">üì¥ End</button>
    <button onclick="cancelCall()">üìµ Cancel</button>
  </div>

  <!-- üëá ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ 2 ‡∏à‡∏≠ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏Å‡∏±‡∏ö -->
  <div id="videoContainer">
    <div class="video-box">
      <div class="video-label">You</div>
      <video id="localVideo" autoplay playsinline muted style="display: none;"></video>
    </div>
    <div class="video-box">
      <div class="video-label">Partner</div>
      <video id="remoteVideo" autoplay playsinline style="display: none;"></video>
    </div>
  </div>

  <audio id="remoteAudio" autoplay></audio>
  <div id="log"></div>

  <script>
    let socket;
    let currentCallId = null;
    let isCaller = false;
    let callStatus = null;
    let localStream = null;
    let peerConnection = null;
    let myUserId = null;
    let otherUserId = null;
    let callType = 'VOICE';
    let incomingCallType = 'VOICE'; // üëà ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å
    const iceQueue = [];

    const iceServers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    function log(msg) {
      const logArea = document.getElementById('log');
      logArea.textContent += msg + '\n';
      logArea.scrollTop = logArea.scrollHeight;
    }

    function connectSocket() {
      myUserId = Number(document.getElementById('userId').value);
      socket = io('https://0b02e4248cf5.ngrok-free.app', {
        query: { userId: myUserId },
        transports: ['websocket'],
      });

      socket.on('connect', () => log(`‚úÖ Connected as user ${myUserId}`));
      socket.on('disconnect', () => log(`‚ùå Disconnected`));
      socket.on('receive_message', (msg) => log(`üì© Message received: ${JSON.stringify(msg)}`));
      socket.on('message_sent', (msg) => log(`üì§ Message sent: ${JSON.stringify(msg)}`));

      socket.on('incoming_call', (call) => {
        log(`üìû Incoming call: ${JSON.stringify(call)}`);
        currentCallId = call.callId;
        otherUserId = call.from;
        isCaller = false;
        callStatus = 'RINGING';
        incomingCallType = call.type || 'VOICE'; // üëà ‡∏à‡∏î‡∏à‡∏≥‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô 'VIDEO'
      });

      socket.on('call_started', async ({ callId }) => {
        currentCallId = callId;
        otherUserId = Number(document.getElementById('receiverId').value);
        isCaller = true;
        callStatus = 'RINGING';
        log(`üìû Call started with ID ${callId}`);
        await startLocalPreview(); // Caller ‡πÄ‡∏´‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
      });

      socket.on('call_accepted', async (data) => {
        log(`‚úÖ Call accepted: ${JSON.stringify(data)}`);
        callType = data.type || 'VOICE';
        callStatus = 'ONGOING';
        await startLocalPreview();     // Receiver ‡πÄ‡∏´‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
        await startWebRTC(isCaller);
      });

      socket.on('call_declined', () => { log(`‚ùå Call declined`); cleanup(); });
      socket.on('call_ended', () => { log(`üì¥ Call ended`); cleanup(); });
      socket.on('call_canceled', () => { log(`üìµ Call canceled`); cleanup(); });

      socket.on('webrtc_offer', async (data) => {
        log('üì® Received WebRTC offer');
        otherUserId = data.from;
        await startWebRTC(false);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('webrtc_answer', { from: myUserId, to: otherUserId, sdp: answer });
        log('üì§ Sent webrtc_answer');
        flushIce();
      });

      socket.on('webrtc_answer', async (data) => {
        log('üì® Received WebRTC answer');
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
      });

      socket.on('ice_candidate', async (data) => {
        log('‚ùÑÔ∏è Received ICE candidate');
        if (!peerConnection || !peerConnection.remoteDescription || peerConnection.remoteDescription.type === '') {
          iceQueue.push(data.candidate);
          log('üïí Queued ICE candidate');
          return;
        }

        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
          log('‚úÖ ICE candidate added');
        } catch (err) {
          log('‚ö†Ô∏è Error adding ICE candidate: ' + err);
        }
      });
    }

    function flushIce() {
      while (iceQueue.length) {
        const candidate = iceQueue.shift();
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
          .then(() => log('‚úÖ Flushed ICE candidate'))
          .catch(err => log('‚ö†Ô∏è Error flushing ICE: ' + err));
      }
    }

    function sendMessage() {
      if (!socket || !socket.connected) return log('‚ö†Ô∏è Not connected');
      const senderId = myUserId;
      const receiverId = Number(document.getElementById('receiverId').value);
      const content = document.getElementById('message').value;
      socket.emit('send_message', { senderId, receiverId, content });
      log(`‚û°Ô∏è Emitted send_message`);
    }

    function startCall(type) {
      if (!socket || !socket.connected) return log('‚ö†Ô∏è Not connected');
      callType = type;
      const callerId = myUserId;
      const receiverId = Number(document.getElementById('receiverId').value);
      socket.emit('start_call', { callerId, receiverId, type });
      log('üìû Emitted start_call (' + type + ')');
    }

    async function acceptCall() {
      if (!currentCallId) return log('‚ö†Ô∏è No call to accept');
      callType = incomingCallType; // üëà ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á
      log('[DEBUG] acceptCall with callType = ' + callType);
      socket.emit('accept_call', { callId: currentCallId, receiverId: myUserId });
      log('‚úÖ Emitted accept_call');
      callStatus = 'ONGOING';
      await startLocalPreview();  // ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏£‡∏±‡∏ö
      await startWebRTC(false);
    }

    function declineCall() {
      if (!currentCallId) return log('‚ö†Ô∏è No call to decline');
      socket.emit('decline_call', { callId: currentCallId, receiverId: myUserId });
      log('‚ùå Emitted decline_call');
      cleanup();
    }

    function endCall() {
      if (!currentCallId || callStatus !== 'ONGOING') return log('‚ö†Ô∏è No active call to end');
      socket.emit('end_call', { callId: currentCallId, userId: myUserId });
      log('üì¥ Emitted end_call');
      cleanup();
    }

    function cancelCall() {
      if (!currentCallId || !isCaller || callStatus !== 'RINGING') return log('‚ö†Ô∏è Cannot cancel now');
      socket.emit('cancel_call', { callId: currentCallId, userId: myUserId });
      log('üìµ Emitted cancel_call');
      cleanup();
    }

    async function startLocalPreview() {
      const localVideoEl = document.getElementById('localVideo');
      const constraints = callType === 'VIDEO' ? { audio: true, video: true } : { audio: true };
      log(`[DEBUG] startLocalPreview with constraints: ${JSON.stringify(constraints)}`);
      try {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        if (callType === 'VIDEO') {
          localVideoEl.srcObject = localStream;
          localVideoEl.style.display = 'block';
        }
      } catch (err) {
        log('‚ö†Ô∏è Error accessing media devices: ' + err);
      }
    }

    async function startWebRTC(isInitiator) {
      if (peerConnection) return;

      const constraints = callType === 'VIDEO' ? { audio: true, video: true } : { audio: true };
      if (!localStream) {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
      }

      peerConnection = new RTCPeerConnection(iceServers);
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      const remoteVideoEl = document.getElementById('remoteVideo');
      const remoteAudioEl = document.getElementById('remoteAudio');

      peerConnection.ontrack = (event) => {
        const stream = event.streams[0];
        if (callType === 'VIDEO') {
          remoteVideoEl.srcObject = stream;
          remoteVideoEl.style.display = 'block';
        }
        remoteAudioEl.srcObject = stream;
        log('üîä Playing remote media');
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && otherUserId) {
          socket.emit('ice_candidate', {
            from: myUserId,
            to: otherUserId,
            candidate: event.candidate
          });
          log('üì§ Sent ICE candidate');
        }
      };

      if (isInitiator) {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('webrtc_offer', {
          from: myUserId,
          to: otherUserId,
          sdp: offer
        });
        log('üì§ Sent webrtc_offer');
      }
    }

    function cleanup() {
      currentCallId = null;
      callStatus = null;
      isCaller = false;
      callType = 'VOICE';

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      document.getElementById('localVideo').style.display = 'none';
      document.getElementById('remoteVideo').style.display = 'none';
      document.getElementById('localVideo').srcObject = null;
      document.getElementById('remoteVideo').srcObject = null;
      document.getElementById('remoteAudio').srcObject = null;
    }
  </script>
</body>
</html>
