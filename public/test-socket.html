<!-- filename: video-call-test.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Socket.IO Audio/Video Call Test</title>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 2rem; background: #f8f8f8; }
    #log { background: #fff; padding: 1rem; border-radius: 8px; border: 1px solid #ccc; height: 300px; overflow-y: scroll; margin-top: 1rem; font-family: monospace; white-space: pre-wrap; }
    input, button { margin: 0.25rem; padding: 0.5rem; }
    video { border-radius: 8px; margin-top: 1rem; }
  </style>
</head>
<body>
  <h1>ğŸ“¡ Socket.IO Audio/Video Call Test</h1>

  <div>
    <label><b>Your User ID:</b></label>
    <input type="number" id="userId" value="1" />
    <button onclick="connectSocket()">Connect</button>
  </div>

  <div>
    <label><b>Receiver ID:</b></label>
    <input type="number" id="receiverId" value="2" />
    <input type="text" id="message" placeholder="Type message..." />
    <button onclick="sendMessage()">Send Message</button>
  </div>

  <div>
    <button onclick="startCall('VOICE')">ğŸ“ Start Audio Call</button>
    <button onclick="startCall('VIDEO')">ğŸ“¹ Start Video Call</button>
    <button onclick="acceptCall()">âœ… Accept</button>
    <button onclick="declineCall()">âŒ Decline</button>
    <button onclick="endCall()">ğŸ“´ End</button>
    <button onclick="cancelCall()">ğŸ“µ Cancel</button>
  </div>

  <video id="localVideo" autoplay playsinline muted style="width: 200px; display: none;"></video>
  <video id="remoteVideo" autoplay playsinline style="width: 300px; display: none;"></video>
  <audio id="remoteAudio" autoplay></audio>
  <div id="log"></div>

  <script>
    let socket;
    let currentCallId = null;
    let isCaller = false;
    let callStatus = null;
    let localStream = null;
    let peerConnection = null;
    let myUserId = null;
    let otherUserId = null;
    let callType = 'VOICE';
    let incomingCallType = 'VOICE'; // ğŸ‘ˆ à¸ªà¸³à¸„à¸±à¸à¸¡à¸²à¸
    const iceQueue = [];

    const iceServers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    function log(msg) {
      const logArea = document.getElementById('log');
      logArea.textContent += msg + '\n';
      logArea.scrollTop = logArea.scrollHeight;
    }

    function connectSocket() {
      myUserId = Number(document.getElementById('userId').value);
      socket = io('https://0b02e4248cf5.ngrok-free.app', {
        query: { userId: myUserId },
        transports: ['websocket'],
      });

      socket.on('connect', () => log(`âœ… Connected as user ${myUserId}`));
      socket.on('disconnect', () => log(`âŒ Disconnected`));
      socket.on('receive_message', (msg) => log(`ğŸ“© Message received: ${JSON.stringify(msg)}`));
      socket.on('message_sent', (msg) => log(`ğŸ“¤ Message sent: ${JSON.stringify(msg)}`));

      socket.on('incoming_call', (call) => {
        log(`ğŸ“ Incoming call: ${JSON.stringify(call)}`);
        currentCallId = call.callId;
        otherUserId = call.from;
        isCaller = false;
        callStatus = 'RINGING';
        incomingCallType = call.type || 'VOICE'; // ğŸ‘ˆ à¸ˆà¸”à¸ˆà¸³à¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ 'VIDEO'
      });

      socket.on('call_started', async ({ callId }) => {
        currentCallId = callId;
        otherUserId = Number(document.getElementById('receiverId').value);
        isCaller = true;
        callStatus = 'RINGING';
        log(`ğŸ“ Call started with ID ${callId}`);
        await startLocalPreview(); // Caller à¹€à¸«à¹‡à¸™à¸•à¸±à¸§à¹€à¸­à¸‡
      });

      socket.on('call_accepted', async (data) => {
        log(`âœ… Call accepted: ${JSON.stringify(data)}`);
        callType = data.type || 'VOICE';
        callStatus = 'ONGOING';
        await startLocalPreview();     // Receiver à¹€à¸«à¹‡à¸™à¸•à¸±à¸§à¹€à¸­à¸‡
        await startWebRTC(isCaller);
      });

      socket.on('call_declined', () => { log(`âŒ Call declined`); cleanup(); });
      socket.on('call_ended', () => { log(`ğŸ“´ Call ended`); cleanup(); });
      socket.on('call_canceled', () => { log(`ğŸ“µ Call canceled`); cleanup(); });

      socket.on('webrtc_offer', async (data) => {
        log('ğŸ“¨ Received WebRTC offer');
        otherUserId = data.from;
        await startWebRTC(false);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('webrtc_answer', { from: myUserId, to: otherUserId, sdp: answer });
        log('ğŸ“¤ Sent webrtc_answer');
        flushIce();
      });

      socket.on('webrtc_answer', async (data) => {
        log('ğŸ“¨ Received WebRTC answer');
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));
      });

      socket.on('ice_candidate', async (data) => {
        log('â„ï¸ Received ICE candidate');
        if (!peerConnection || !peerConnection.remoteDescription || peerConnection.remoteDescription.type === '') {
          iceQueue.push(data.candidate);
          log('ğŸ•’ Queued ICE candidate');
          return;
        }

        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
          log('âœ… ICE candidate added');
        } catch (err) {
          log('âš ï¸ Error adding ICE candidate: ' + err);
        }
      });
    }

    function flushIce() {
      while (iceQueue.length) {
        const candidate = iceQueue.shift();
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
          .then(() => log('âœ… Flushed ICE candidate'))
          .catch(err => log('âš ï¸ Error flushing ICE: ' + err));
      }
    }

    function sendMessage() {
      if (!socket || !socket.connected) return log('âš ï¸ Not connected');
      const senderId = myUserId;
      const receiverId = Number(document.getElementById('receiverId').value);
      const content = document.getElementById('message').value;
      socket.emit('send_message', { senderId, receiverId, content });
      log(`â¡ï¸ Emitted send_message`);
    }

    function startCall(type) {
      if (!socket || !socket.connected) return log('âš ï¸ Not connected');
      callType = type;
      const callerId = myUserId;
      const receiverId = Number(document.getElementById('receiverId').value);
      socket.emit('start_call', { callerId, receiverId, type });
      log('ğŸ“ Emitted start_call (' + type + ')');
    }

    async function acceptCall() {
      if (!currentCallId) return log('âš ï¸ No call to accept');
      callType = incomingCallType; // ğŸ‘ˆ à¹€à¸‹à¹‡à¸•à¸à¹ˆà¸­à¸™à¹€à¸›à¸´à¸”à¸à¸¥à¹‰à¸­à¸‡
      log('[DEBUG] acceptCall with callType = ' + callType);
      socket.emit('accept_call', { callId: currentCallId, receiverId: myUserId });
      log('âœ… Emitted accept_call');
      callStatus = 'ONGOING';
      await startLocalPreview();  // âœ… à¹€à¸›à¸´à¸”à¸à¸¥à¹‰à¸­à¸‡à¸à¸±à¹ˆà¸‡à¸£à¸±à¸š
      await startWebRTC(false);
    }

    function declineCall() {
      if (!currentCallId) return log('âš ï¸ No call to decline');
      socket.emit('decline_call', { callId: currentCallId, receiverId: myUserId });
      log('âŒ Emitted decline_call');
      cleanup();
    }

    function endCall() {
      if (!currentCallId || callStatus !== 'ONGOING') return log('âš ï¸ No active call to end');
      socket.emit('end_call', { callId: currentCallId, userId: myUserId });
      log('ğŸ“´ Emitted end_call');
      cleanup();
    }

    function cancelCall() {
      if (!currentCallId || !isCaller || callStatus !== 'RINGING') return log('âš ï¸ Cannot cancel now');
      socket.emit('cancel_call', { callId: currentCallId, userId: myUserId });
      log('ğŸ“µ Emitted cancel_call');
      cleanup();
    }

    async function startLocalPreview() {
      const localVideoEl = document.getElementById('localVideo');
      const constraints = callType === 'VIDEO' ? { audio: true, video: true } : { audio: true };
      log(`[DEBUG] startLocalPreview with constraints: ${JSON.stringify(constraints)}`);
      try {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        if (callType === 'VIDEO') {
          localVideoEl.srcObject = localStream;
          localVideoEl.style.display = 'block';
        }
      } catch (err) {
        log('âš ï¸ Error accessing media devices: ' + err);
      }
    }

    async function startWebRTC(isInitiator) {
      if (peerConnection) return;

      const constraints = callType === 'VIDEO' ? { audio: true, video: true } : { audio: true };
      if (!localStream) {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
      }

      peerConnection = new RTCPeerConnection(iceServers);
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      const remoteVideoEl = document.getElementById('remoteVideo');
      const remoteAudioEl = document.getElementById('remoteAudio');

      peerConnection.ontrack = (event) => {
        const stream = event.streams[0];
        if (callType === 'VIDEO') {
          remoteVideoEl.srcObject = stream;
          remoteVideoEl.style.display = 'block';
        }
        remoteAudioEl.srcObject = stream;
        log('ğŸ”Š Playing remote media');
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate && otherUserId) {
          socket.emit('ice_candidate', {
            from: myUserId,
            to: otherUserId,
            candidate: event.candidate
          });
          log('ğŸ“¤ Sent ICE candidate');
        }
      };

      if (isInitiator) {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('webrtc_offer', {
          from: myUserId,
          to: otherUserId,
          sdp: offer
        });
        log('ğŸ“¤ Sent webrtc_offer');
      }
    }

    function cleanup() {
      currentCallId = null;
      callStatus = null;
      isCaller = false;
      callType = 'VOICE';

      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      document.getElementById('localVideo').style.display = 'none';
      document.getElementById('remoteVideo').style.display = 'none';
      document.getElementById('localVideo').srcObject = null;
      document.getElementById('remoteVideo').srcObject = null;
      document.getElementById('remoteAudio').srcObject = null;
    }
  </script>
</body>
</html>
